

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/morty.jpeg">
  <link rel="icon" href="/img/morty.jpeg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="kayce">
  <meta name="keywords" content="">
  
    <meta name="description" content="(WIP) POV - Rust Atomics and Locks">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust Atomics and Locks">
<meta property="og:url" content="https://kayce.world/tech/rust_atomics_and_locks/index.html">
<meta property="og:site_name" content="kayce">
<meta property="og:description" content="(WIP) POV - Rust Atomics and Locks">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-18T08:01:50.000Z">
<meta property="article:modified_time" content="2025-01-20T06:50:00.000Z">
<meta property="article:author" content="kayce">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Rust Atomics and Locks - kayce</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_4789608_0mu4sl00qiuq.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kayce.world","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":false,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>kayce&#39;s world</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/" target="_self">
                <i class="iconfont icon-music"></i>
                <span>Music</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/RanchoNight_16_Tree.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust Atomics and Locks"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        kayce
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-18 16:01" pubdate>
          December 18, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Rust Atomics and Locks</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    Last updated on January 20, 2025 pm
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <div class="note note-warning">
            <p>WIP, No ETA provided</p>
          </div>
<div class="note note-danger">
            <p>TL;DR - Please refer to the ToC on the right side</p>
          </div>
<blockquote>
<p>The <strong><em>tremendous</em></strong> book<br>
<a target="_blank" rel="noopener" href="https://marabos.nl/atomics/"><em>Rust Atomics and Locks</em></a> by <a target="_blank" rel="noopener" href="https://marabos.nl/">Mara Bos</a><br>
in my POV.</p>
</blockquote>
<h2 id="Cell-RefCell">Cell, RefCell</h2>
<p><strong><em>Interior mutability</em></strong>: a design pattern in Rust that allows you to mutate data even when there are immutable references to that data.</p>
<p>In short, you can use <code>fn foo(&amp;self)</code> to change the data inside the struct. Normally, we have to use <code>fn foo(&amp;mut self)</code>.</p>
<p><strong>Cell</strong></p>
<ul>
<li><code>take()</code> out the data, modify it, and <code>set()</code> it back.
<blockquote>
<p><code>Mutex</code> is the concurrent version of <code>Cell</code>.</p>
</blockquote>
</li>
</ul>
<p><strong>Refcell:</strong></p>
<ul>
<li><code>borrow_mut()</code> will panic if there’s already a mutable borrow.
<blockquote>
<p><code>RWMutex</code> is the concurrent version of <code>RefCell</code>, but it will block until the mutable borrow is released instead of panicking.</p>
</blockquote>
</li>
</ul>
<div class="note note-light">
            <p><strong><em>Aside: UnsafeCell</em></strong></p><p>Both of them are built with a core primitive called <code>UnsafeCell</code>.</p><p>This struct provides the basic abstraction for interior mutability, however, you have to use <code>unsafe</code> to access.</p><p><code>Cell</code>, <code>RefCell</code> and all other types that allows internal mutability use <code>UnsafeCell</code> to wrap their data and provide <code>safe</code> apis.</p>
          </div>
<h2 id="MutexGuard-lifetime">MutexGuard lifetime</h2>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> list.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop</span>() == <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// &lt;--- drop here</span>
    <span class="hljs-title function_ invoke__">do_something</span>();
&#125;

<span class="hljs-comment">// PERF: needlessly hold on to the lock while processing the item.</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = list.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop</span>() &#123;
    <span class="hljs-title function_ invoke__">process_item</span>(item);
&#125; <span class="hljs-comment">// &lt;--- drop here</span>

<span class="hljs-comment">// FIXED:</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = list.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop</span>(); <span class="hljs-comment">// &lt;--- drop here</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = item &#123;
    <span class="hljs-title function_ invoke__">process_item</span>(item);
&#125;</code></pre></div>
<p>Reason:</p>
<ul>
<li>The basic <code>if</code> statement is always a simple <code>boolean</code> expression.</li>
<li>If we replace <code>pop()</code> with <code>front()</code>, things’re clear. That’s how borrow checker works.</li>
</ul>
<h2 id="Parking">Parking</h2>
<p>Consider this situation: we only process items when the list is not empty.<br>
If we use <code>Mutex</code>, then we have to keep calling <code>lock()</code> again and again, which is not efficient.</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::VecDeque;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">queue</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(VecDeque::<span class="hljs-title function_ invoke__">new</span>());

    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;
        <span class="hljs-comment">// Consuming thread</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = s.<span class="hljs-title function_ invoke__">spawn</span>(|| <span class="hljs-keyword">loop</span> &#123;
            <span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop_front</span>();
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = item &#123;
                dbg!(item);
            &#125; <span class="hljs-keyword">else</span> &#123;
                thread::<span class="hljs-title function_ invoke__">park</span>();
            &#125;
        &#125;);

        <span class="hljs-comment">// Producing thread</span>
        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. &#123;
            queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">push_back</span>(i);
            t.<span class="hljs-title function_ invoke__">thread</span>().<span class="hljs-title function_ invoke__">unpark</span>();
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));
        &#125;
    &#125;);
&#125;</code></pre></div>
<div class="note note-primary">
            <p>A call to <code>unpark()</code> before the thread parks itself <strong><em>does not get lost</em></strong></p><p>However, unpark requests <strong><em>don’t stack up</em></strong>.</p><p>Calling unpark() two times and then calling park() two times afterwards still results in the thread going to sleep.</p>
          </div>
<h2 id="Cond-Vars">Cond Vars</h2>
<p>The example above is low-efficiency when we want to use more consumers.<br>
Because the producer doesn’t know which consumer to wake up.</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">use</span> std::sync::Condvar;
    <span class="hljs-keyword">use</span> std::&#123;collections::VecDeque, sync::Mutex, thread, time::Duration&#125;;

    <span class="hljs-keyword">let</span> <span class="hljs-variable">queue</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(VecDeque::<span class="hljs-title function_ invoke__">new</span>());
    <span class="hljs-keyword">let</span> <span class="hljs-variable">not_empty</span> = Condvar::<span class="hljs-title function_ invoke__">new</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">empty</span> = Condvar::<span class="hljs-title function_ invoke__">new</span>();

    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;
        <span class="hljs-comment">// not_empty handler</span>
        s.<span class="hljs-title function_ invoke__">spawn</span>(|| <span class="hljs-keyword">loop</span> &#123;
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">q</span> = queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
            <span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = <span class="hljs-keyword">loop</span> &#123;
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = q.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;
                    <span class="hljs-keyword">break</span> item;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    empty.<span class="hljs-title function_ invoke__">notify_one</span>(); <span class="hljs-comment">// wake up the empty handler(s)</span>
                    q = not_empty.<span class="hljs-title function_ invoke__">wait</span>(q).<span class="hljs-title function_ invoke__">unwrap</span>();
                &#125;
            &#125;;
            <span class="hljs-title function_ invoke__">drop</span>(q);
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got item: &#123;&#125;&quot;</span>, item);
        &#125;);

        <span class="hljs-comment">// empty handler</span>
        s.<span class="hljs-title function_ invoke__">spawn</span>(|| <span class="hljs-keyword">loop</span> &#123;
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">q</span> = queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
            <span class="hljs-keyword">loop</span> &#123;
                <span class="hljs-keyword">if</span> q.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;
                    <span class="hljs-keyword">break</span>;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    q = empty.<span class="hljs-title function_ invoke__">wait</span>(q).<span class="hljs-title function_ invoke__">unwrap</span>();
                &#125;
            &#125;
            <span class="hljs-title function_ invoke__">drop</span>(q);
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">400</span>));
        &#125;);

        <span class="hljs-comment">// producer</span>
        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. &#123;
            queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">push_back</span>(i);
            not_empty.<span class="hljs-title function_ invoke__">notify_one</span>(); <span class="hljs-comment">// wake up the not_empty handler(s)</span>
            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));
        &#125;
    &#125;);
&#125;</code></pre></div>
<h2 id="Memory-Ordering">Memory Ordering</h2>
<h3 id="Happens-Before">Happens-Before</h3>
<p>Before we dive into the specific memory orderings below, we must have a deep understanding of <code>happens-before</code> relationship.</p>
<p><code>happens-before</code> dose not mean that the first operation is literally executed before the second one. (If you want to achieve that, you should use <code>Mutex</code>, <code>CondVar</code>, <code>Chan</code> or other synchronization primitives to help threads communicate.)</p>
<p>There’re 2 points to remember:</p>
<ol>
<li>
<p><code>happens-before</code> is all about the ‘instruction reordering’ by the compiler or the CPU.</p>
</li>
<li>
<p><code>happens-before</code> itself doesn’t happen until <code>observable behavior</code> occurs.</p>
</li>
</ol>
<p>For example:</p>
<div class="code-wrapper"><pre><code class="hljs text">
Thread A:                          Thread B:

some ops (A) ----------
...                   |
a.store(1, Release);  | visible
                      |
                      |     if a.load(Acquire) == 1 &#123;
                      -&gt; (B)    // do something
                            &#125;</code></pre></div>
<p>There’s no <code>happens-before</code> relationship until Thread B sees the value <code>1</code> in <code>a.load(Acquire)</code>, and at that point, we can say that <code>(A)</code> happens before <code>(B)</code>, or <code>(A)</code> is visible to <code>(B)</code>.</p>
<h3 id="Relaxed">Relaxed</h3>
<p>While atomic operations using relaxed memory ordering do not provide any happens-before relationship,<br>
they do guarantee a total modification order of each individual atomic variable.<br>
This means that all modifications of the same atomic variable happen in an order that is the same from the perspective of every single thread.</p>
<p>Example:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);

<span class="hljs-comment">// thread 1</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>() &#123;
    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);
    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed);
&#125;

<span class="hljs-comment">// thread 2</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);
&#125;</code></pre></div>
<p>The output will never be <code>0 5 0 15</code> or <code>0 0 10 15</code> due to the order of the 2 <code>fetch_add</code> ops.</p>
<ul>
<li><code>0 5 0 15</code>: since we’ve written 5 and it has been read, the next read mustn’t be 0.</li>
<li><code>0 0 10 15</code>: write 5 happens before write 10.</li>
</ul>
<hr>
<h3 id="Release-Acquire">Release / Acquire</h3>
<p><code>Release</code> corresponds to the <code>store</code> operation, and <code>Acquire</code> corresponds to the <code>load</code> operation.</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::Ordering::&#123;Acquire, Release&#125;;

<span class="hljs-keyword">static</span> DATA: AtomicU64 = AtomicU64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;
        DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Relaxed);
        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// Everything from before this store ..</span>
    &#125;);
    <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123; <span class="hljs-comment">// .. is visible after this loads `true`.</span>
        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);
    &#125;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, DATA.<span class="hljs-title function_ invoke__">load</span>(Relaxed));
&#125;</code></pre></div>
<div class="note note-info">
            <p>Note that if we use <code>Relaxed</code> instead of <code>Acquire</code> for <code>READY</code>, we might read <code>0</code> instead of <code>123</code>.<br>That’s because <code>Relaxed</code> only provides a total order for the <strong><em>same</em></strong> atomic variable, not across <strong><em>different</em></strong> variables.</p>
          </div>
<p>Since <code>Release</code> and <code>Acquire</code> have a happens-before relationship, we can simply use <code>u64</code> instead of <code>AtomicU64</code>:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;
        <span class="hljs-comment">// Safety: Nothing else is accessing DATA,</span>
        <span class="hljs-comment">// because we haven&#x27;t set the READY flag yet.</span>
        <span class="hljs-keyword">unsafe</span> &#123; DATA = <span class="hljs-number">123</span> &#125;;
        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// Everything from before this store ..</span>
    &#125;);
    <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123;
        <span class="hljs-comment">// .. is visible after this loads `true`.</span>
        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);
    &#125;
    <span class="hljs-comment">// Safety: Nothing is mutating DATA, because READY is set.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; DATA &#125;);
&#125;</code></pre></div>
<hr>
<h3 id="SeqCst">SeqCst</h3>
<p>To be short, the order of excution is just like the order of the codes.<br>
Here’s a example of the difference between <code>Acq/Rel</code> and <code>SeqCst</code>:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> A: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">static</span> B: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread1</span>() &#123;
    A.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, SeqCst);
    B.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, SeqCst);
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread2</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = B.<span class="hljs-title function_ invoke__">load</span>(SeqCst);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = A.<span class="hljs-title function_ invoke__">load</span>(SeqCst);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);
&#125;</code></pre></div>
<blockquote>
<p>If b is <code>2</code> then a must be <code>1</code>.</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> A: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">static</span> B: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread1</span>() &#123;
    A.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Release);
    B.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread2</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = B.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = A.<span class="hljs-title function_ invoke__">load</span>(Acquire);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);
&#125;</code></pre></div>
<blockquote>
<p>If b is <code>2</code>, we can’t guarantee that a is <code>1</code>.</p>
</blockquote>
<hr>
<h3 id="Fence">Fence</h3>
<p>To be short, <code>fence</code> stops the compiler from reordering instructions following the fence with instructions preceding the fence.</p>
<blockquote>
<p>More specifically, a <code>fence(Release)</code> will prevent the <strong><em>store</em></strong> instructions being reordered <strong><em>after</em></strong> the fence, and a <code>fence(Acquire)</code> will prevent the <strong><em>read</em></strong> instructions being reordered <strong><em>before</em></strong> the fence.</p>
</blockquote>
<p>We’ve already known that <code>Release</code> and <code>Acquire</code> have a happens-before relationship, and we can use <code>fence</code> to substitute them like this:</p>
<p><strong>before:</strong></p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// Thread A</span>
&#123;
    DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Relaxed);
    READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// What happens-before the `Release`...</span>
&#125;

<span class="hljs-comment">// Thread B</span>
<span class="hljs-keyword">if</span> READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123;            <span class="hljs-comment">// ... is visible after the `Acquire`.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = DATA.<span class="hljs-title function_ invoke__">load</span>(Relaxed); <span class="hljs-comment">// The observation has occured (READY false -&gt; true), so we can see the value must be 42.</span>
    <span class="hljs-built_in">assert_eq!</span>(value, <span class="hljs-number">42</span>);
&#125;</code></pre></div>
<p><strong>after:</strong></p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// Thread A</span>
&#123;
    DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Relaxed);

    <span class="hljs-title function_ invoke__">fence</span>(Release);             <span class="hljs-comment">// fence before store</span>
    READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Relaxed); <span class="hljs-comment">// just Relaxed</span>
&#125;

<span class="hljs-comment">// Thread B</span>
<span class="hljs-keyword">if</span> READY.<span class="hljs-title function_ invoke__">load</span>(Relaxed) &#123; <span class="hljs-comment">// just Relaxed</span>
    <span class="hljs-title function_ invoke__">fence</span>(Acquire);      <span class="hljs-comment">// fence after load</span>

    <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = DATA.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
    <span class="hljs-built_in">assert_eq!</span>(value, <span class="hljs-number">42</span>);
&#125;</code></pre></div>
<ol>
<li><code>fence</code> after <code>load</code>:</li>
</ol>
<p>Let’s say, if we move the <code>fence</code> to the front of the <code>if</code> block, then the compiler <strong><em>might</em></strong> reorder the <code>load</code> before the <code>if</code> check:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// Thread B</span>
<span class="hljs-title function_ invoke__">fence</span>(Acquire);
<span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = DATA.<span class="hljs-title function_ invoke__">load</span>(Relaxed); <span class="hljs-comment">// what value will be?</span>
<span class="hljs-keyword">if</span> READY.<span class="hljs-title function_ invoke__">load</span>(Relaxed) &#123;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;DATA = &#123;&#125;&quot;</span>, value);
&#125;</code></pre></div>
<p>So we’ll probably get <code>DATA = 0</code> instead of <code>DATA = 42</code>.</p>
<ol start="2">
<li><code>fence</code> before <code>store</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs rust">&#123;
    DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Relaxed);
    <span class="hljs-title function_ invoke__">fence</span>(Release); <span class="hljs-comment">// make sure DATA is stored</span>
    READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Relaxed);
&#125;</code></pre></div>
<p>Finally, check another example to make a deeper impression - use <code>fence</code> to get better performance:</p>
<div style="display: flex; flex-direction: row; justify-content: space-between;">
  <div style="width: 49%;">
    <div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = PTR.<span class="hljs-title function_ invoke__">load</span>(Acquire);
<span class="hljs-keyword">if</span> p.<span class="hljs-title function_ invoke__">is_null</span>() &#123;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no data&quot;</span>);
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;data = &#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; *p &#125;);
&#125;

</code></pre></div>
  </div>
  <div style="width: 49%;">
    <div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = PTR.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
<span class="hljs-keyword">if</span> p.<span class="hljs-title function_ invoke__">is_null</span>() &#123;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no data&quot;</span>);
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-title function_ invoke__">fence</span>(Acquire);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;data = &#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; *p &#125;);
&#125;</code></pre></div>
  </div>
</div>
<div class="note note-info">
            <ul><li><p>Why is the performance better?<br>Because the <code>fence</code> is only needed when <code>p</code> is not null, and load by <code>Relaxed</code> is lighter weight than <code>Acquire</code>.</p></li><li><p>How does it work?<br>Because <code>fence</code> stops <code>*p</code> from being reordered before the <code>if</code> check, and we can avoid the <code>Acquire</code> load when <code>p</code> is null.</p></li></ul>
          </div>
<div class="note note-second">
            <p>Any way, if you find it hard to understand, keeping these 2 rules in mind might help:</p><div class="code-wrapper"><pre><code class="hljs rust">a.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Release);
<span class="hljs-comment">// equals to</span>
<span class="hljs-title function_ invoke__">fence</span>(Release);
a.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Relaxed);</code></pre></div><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = b.<span class="hljs-title function_ invoke__">load</span>(Acquire);
<span class="hljs-comment">// equals to</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = b.<span class="hljs-title function_ invoke__">load</span>(Relaxed);
<span class="hljs-title function_ invoke__">fence</span>(Acquire);</code></pre></div><p>If you simply do ‘Variable Replacement’, you’ll see that a <code>fence</code> isn’t actually dependent on another <code>fence</code>, it can also work with a <code>store</code> or a <code>load</code>.</p><p>i.e. A <code>fence(Acquire)</code> doesn’t have to work with a <code>fence(Release)</code>, we don’t have to use <code>fence</code> in pairs.</p><p>And that’s how the last example works.</p><p>PS: The ‘replacement’ doesn’t strictly requires you to do something like <code>:s/ori/new</code>. Of course you can add some lines between <code>fence</code> and <code>store</code> / <code>load</code>, as long as the codes you add don’t care about the mem order.</p>
          </div>
<hr>
<h3 id="Misconceptions">Misconceptions</h3>
<ol>
<li><strong>I need strong memory ordering to make sure changes are immediately visible to other threads.</strong></li>
</ol>
<ul>
<li>In real life, memory ordering is about things like reordering instructions, which usually happen at nanosecond scale.<br>
Stronger memory ordering does not make your data travel faster; it might even slow your program down.</li>
</ul>
<ol start="2">
<li><strong>Disabling optimization means I don’t need to care about memory ordering.</strong></li>
</ol>
<ul>
<li>Processor optimizations still happen even if you disable compiler optimizations.</li>
</ul>
<ol start="3">
<li><strong>Sequentially consistent memory ordering can be used for a “release-load” or an “acquire-store.”</strong></li>
</ol>
<ul>
<li>Release-store <strong><em>does not</em></strong> form any release-acquire relationship with a SeqCst-store.<br>
If you need them to be part of a globally consistent order, <u>both operations will have to use SeqCst</u>.</li>
</ul>
<hr>
<h3 id="Summary">Summary</h3>
<table>
<thead>
<tr>
<th>type</th>
<th>guarantee</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relaxed</td>
<td>Total modification order of a specific single atomic variable</td>
</tr>
<tr>
<td>Acq/Rel</td>
<td>Make sure changes before “Rel” are visible to “Acq”</td>
</tr>
<tr>
<td>SeqCst</td>
<td>Just like the order of the codes look like</td>
</tr>
<tr>
<td>Fence</td>
<td>Codes after the fence are not reordered with the codes before the fence</td>
</tr>
</tbody>
</table>
<div class="note note-light">
            <p><strong><em>Aside: <code>compare_exchange</code> vs. <code>compare_exchange_weak</code></em></strong></p><p>To be short, <code>compare_exchange_weak</code> might return <code>Err</code> even if the comparison is successful.</p><p>This is because the low-level instructions of <code>_weak</code> is <code>LL/SC</code> (Load-Linked/Store-Conditional), which might fail due to cache contention.</p><p>Since we always need to use <code>while</code> loop to retry, <code>compare_exchange_weak</code> is <strong>more efficient</strong> on some specific platforms, such as <code>ARM</code>.</p><p>What’s more, since the <code>x86/x64</code> arch provides a strong memory named <code>TSO</code> (Total Store Order), thus <code>store(Release)</code> or <code>load(Acquire)</code> might simply be compiled into a <code>MOV</code> instruction;</p><p>However, on <code>ARM</code>, the memory model is less strict, so the compiler might generate a <code>DMB</code> (Data Memory Barrier) instruction for <code>Release</code> or <code>Acquire</code>.</p>
          </div>
<h2 id="Spin-Lock">Spin Lock</h2>
<blockquote>
<p>If a lock is only ever held for very brief moments and the threads locking it can run in parallel on <strong><u>different processor cores</u></strong>,<br>
it might be better for the threads to repeatedly try to lock it without actually going to sleep.</p>
</blockquote>
<h3 id="Minimal-Impl">Minimal Impl</h3>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SpinLock</span> &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;
        <span class="hljs-keyword">Self</span> &#123; locked: AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>) &#125;
    &#125;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">swap</span>(<span class="hljs-literal">true</span>, Acquire) &#123;
            std::hint::<span class="hljs-title function_ invoke__">spin_loop</span>();
        &#125;
    &#125;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Release);
    &#125;
&#125;</code></pre></div>
<hr>
<h3 id="Hold-value">Hold value</h3>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpinLock</span>&lt;T&gt; &#123;
    locked: AtomicBool,
    value: UnsafeCell&lt;T&gt;,
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;
        <span class="hljs-keyword">Self</span> &#123;
            locked: AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>),
            value: UnsafeCell::<span class="hljs-title function_ invoke__">new</span>(value),
        &#125;
    &#125;

    <span class="hljs-comment">// use this macro to suppress the clippy error</span>
    <span class="hljs-meta">#[allow(clippy::mut_from_ref)]</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> T &#123;
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">swap</span>(<span class="hljs-literal">true</span>, Acquire) &#123;
            std::hint::<span class="hljs-title function_ invoke__">spin_loop</span>();
        &#125;
        <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.value.<span class="hljs-title function_ invoke__">get</span>() &#125;
    &#125;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Release);
    &#125;
&#125;</code></pre></div>
<hr>
<h3 id="Use-Guard-to-auto-unlock">Use Guard to auto unlock</h3>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guard</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;
    lock: &amp;<span class="hljs-symbol">&#x27;a</span> SpinLock&lt;T&gt;,
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Guard</span>&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;
        <span class="hljs-keyword">unsafe</span> &#123; &amp;*<span class="hljs-keyword">self</span>.lock.value &#125;
    &#125;
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; DerefMut <span class="hljs-keyword">for</span> <span class="hljs-title class_">Guard</span>&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>::Target &#123;
        <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.lock.value &#125;
    &#125;
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Guard</span>&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">self</span>.lock.<span class="hljs-title function_ invoke__">unlock</span>();
    &#125;
&#125;</code></pre></div>
<p>Now let’s change the <code>lock</code> method to return a <code>Guard</code>:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Guard&lt;T&gt; &#123;
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">swap</span>(<span class="hljs-literal">true</span>, Acquire) &#123;
            std::hint::<span class="hljs-title function_ invoke__">spin_loop</span>();
        &#125;
        Guard &#123; lock: <span class="hljs-keyword">self</span> &#125;
    &#125;
&#125;</code></pre></div>
<hr>
<h3 id="Fence-it">Fence it!</h3>
<p>Remember we’ve talked about using <code>fence</code> to substitute <code>load</code> or <code>store</code> in the previous section <a href="#Fence">Fence</a>? There happens to be an example of building a <code>SpinLock</code> with <code>fence</code> in the rust doc of <code>fence</code> itself:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mutex</span> &#123;
    flag: AtomicBool,
&#125;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Mutex</span> &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Mutex &#123;
        Mutex &#123;
            flag: AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>),
        &#125;
    &#125;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-comment">// Wait until the old value is `false`.</span>
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>
            .flag
            .<span class="hljs-title function_ invoke__">compare_exchange_weak</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, Ordering::Relaxed, Ordering::Relaxed)
            .<span class="hljs-title function_ invoke__">is_err</span>()
        &#123;&#125;
        <span class="hljs-comment">// This fence synchronizes-with store in `unlock`.</span>
        <span class="hljs-title function_ invoke__">fence</span>(Ordering::Acquire);
    &#125;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">self</span>.flag.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Ordering::Release);
    &#125;
&#125;</code></pre></div>
<p>A little bit confused of the single <code>fence</code>? Let’s break it down:</p>
<p>First, to see things clearly, we can cast the <code>while</code> loop to a <code>loop</code>:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
    <span class="hljs-comment">// Wait until the old value is `false`.</span>
    <span class="hljs-keyword">loop</span> &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>
            .flag
            .<span class="hljs-title function_ invoke__">compare_exchange_weak</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, Ordering::Relaxed, Ordering::Relaxed)
            .<span class="hljs-title function_ invoke__">is_ok</span>()
        &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-comment">// This fence synchronizes-with store in `unlock`.</span>
    <span class="hljs-title function_ invoke__">fence</span>(Ordering::Acquire);
&#125;</code></pre></div>
<p>Then, we replace <code>compare_exchange_weak</code> with <code>load</code> and <code>store</code>, note that this is <span class="label label-danger">impossible</span> in real code because split <code>cas</code> into individual <code>load</code> and <code>store</code> will break the atomicity:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
    <span class="hljs-comment">// Wait until the old value is `false`.</span>
    <span class="hljs-keyword">loop</span> &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.flag.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="hljs-literal">false</span> &#123;
            <span class="hljs-keyword">self</span>.flag.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-comment">// This fence synchronizes-with store in `unlock`.</span>
    <span class="hljs-title function_ invoke__">fence</span>(Ordering::Acquire);
&#125;</code></pre></div>
<p>Do a little bit adjustment:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
    <span class="hljs-comment">// Wait until the old value is `false`.</span>
    <span class="hljs-keyword">loop</span> &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.flag.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="hljs-literal">false</span> &#123;
            <span class="hljs-title function_ invoke__">fence</span>(Ordering::Acquire);
            <span class="hljs-keyword">self</span>.flag.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;</code></pre></div>
<p>Now we can see that <code>fence</code> after <code>load</code> pattern! It’s equivalent to:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;
    <span class="hljs-comment">// Wait until the old value is `false`.</span>
    <span class="hljs-keyword">loop</span> &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.flag.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) == <span class="hljs-literal">false</span> &#123;
            <span class="hljs-keyword">self</span>.flag.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;</code></pre></div>
<p>And that’s exactly how does the <code>fence</code> synchronizes-with the <code>store</code> in <code>unlock</code>.</p>
<p>It’s a little bit verbose, but it’s a good way to understand how <code>fence</code> works.</p>
<h2 id="Chan">Chan</h2>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Channel</span>&lt;T&gt; &#123;
    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,
    ready: AtomicBool,
&#125;

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Channel</span>&lt;T&gt; <span class="hljs-keyword">where</span> T: <span class="hljs-built_in">Send</span> &#123;&#125;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sender</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;
    channel: &amp;<span class="hljs-symbol">&#x27;a</span> Channel&lt;T&gt;,
    recv_thread: Thread,
&#125;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Receiver</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;
    channel: &amp;<span class="hljs-symbol">&#x27;a</span> Channel&lt;T&gt;,
    _marker: std::marker::PhantomData&lt;&amp;<span class="hljs-symbol">&#x27;a</span> T&gt;,
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;
        <span class="hljs-keyword">Self</span> &#123;
            message: UnsafeCell::<span class="hljs-title function_ invoke__">new</span>(MaybeUninit::<span class="hljs-title function_ invoke__">uninit</span>()),
            ready: AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>),
        &#125;
    &#125;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">split</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> (Sender&lt;T&gt;, Receiver&lt;T&gt;) &#123;
        *<span class="hljs-keyword">self</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">new</span>();
        (
            Sender &#123;
                channel: <span class="hljs-keyword">self</span>,
                recv_thread: thread::<span class="hljs-title function_ invoke__">current</span>(),
            &#125;,
            Receiver &#123;
                channel: <span class="hljs-keyword">self</span>,
                _marker: std::marker::PhantomData,
            &#125;,
        )
    &#125;
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; Sender&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(<span class="hljs-keyword">self</span>, message: T) &#123;
        <span class="hljs-keyword">unsafe</span> &#123; (*<span class="hljs-keyword">self</span>.channel.message.<span class="hljs-title function_ invoke__">get</span>()).<span class="hljs-title function_ invoke__">write</span>(message) &#125;;
        <span class="hljs-keyword">self</span>.channel.ready.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release);
        <span class="hljs-keyword">self</span>.recv_thread.<span class="hljs-title function_ invoke__">unpark</span>();
    &#125;
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; Receiver&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_ready</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;
        <span class="hljs-keyword">self</span>.channel.ready.<span class="hljs-title function_ invoke__">load</span>(Relaxed)
    &#125;

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">receive</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> T &#123;
        <span class="hljs-keyword">while</span> !<span class="hljs-keyword">self</span>.channel.ready.<span class="hljs-title function_ invoke__">swap</span>(<span class="hljs-literal">false</span>, Acquire) &#123;
            thread::<span class="hljs-title function_ invoke__">park</span>();
        &#125;
        <span class="hljs-keyword">unsafe</span> &#123; (*<span class="hljs-keyword">self</span>.channel.message.<span class="hljs-title function_ invoke__">get</span>()).<span class="hljs-title function_ invoke__">assume_init_read</span>() &#125;
    &#125;
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Channel</span>&lt;T&gt; &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">if</span> *<span class="hljs-keyword">self</span>.ready.<span class="hljs-title function_ invoke__">get_mut</span>() &#123;
            <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-keyword">self</span>.message.<span class="hljs-title function_ invoke__">get_mut</span>().<span class="hljs-title function_ invoke__">assume_init_drop</span>() &#125;
        &#125;
    &#125;
&#125;</code></pre></div>
<p>Pay attention to these points:</p>
<ol>
<li>Use <code>MaybeUninit</code> to save memory.</li>
<li>Abstract <code>Sender</code> and <code>Receiver</code> to limit the user’s access to the channel.(Think about the <code>MutexGuard</code> in <code>Mutex</code>)</li>
<li>Use thread handle to park / unpark the receiver thread.</li>
<li>Do not forget to drop the <code>MaybeUninit</code> due to the struct won’t drop the inner data automatically.</li>
</ol>
<h2 id="Arc">Arc</h2>
<h3 id="Minimal-Impl-2">Minimal Impl</h3>
<ul>
<li>
<p>snippet 1:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcData</span>&lt;T&gt; &#123;
    ref_cnt: AtomicUsize,
    data: T,
&#125;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;
    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,
&#125;

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>&gt; <span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;</code></pre></div>
<ul>
<li><code>NonNull</code> is almost same as <code>*mut T</code> but non-null and [covariant]</li>
<li><code>Arc&lt;T&gt;</code> should be shared between threads, so <code>T</code> should be <code>Sync</code>.</li>
<li><code>Arc&lt;T&gt;</code> could be dropped by other threads, so <code>T</code> should be <code>Send</code>.</li>
</ul>
</li>
<li>
<p>snippet 2:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: T) <span class="hljs-punctuation">-&gt;</span> Arc&lt;T&gt; &#123;
        Arc &#123;
            ptr: NonNull::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ArcData &#123;
                ref_count: AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>),
                data,
            &#125;))),
        &#125;
    &#125;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">data</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;
        <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-keyword">self</span>.ptr.<span class="hljs-title function_ invoke__">as_ref</span>() &#125;
    &#125;
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;
        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">data</span>().data
    &#125;
&#125;</code></pre></div>
<ul>
<li>Use <code>Box::leak</code> to give up the exclusive ownership of a <code>Box</code> allocation.</li>
</ul>
</li>
<li>
<p>snippet 3:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Clone</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">data</span>().ref_count.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Relaxed) &gt; <span class="hljs-type">usize</span>::MAX / <span class="hljs-number">2</span> &#123;
            std::process::<span class="hljs-title function_ invoke__">abort</span>();
        &#125;
        Arc &#123; ptr: <span class="hljs-keyword">self</span>.ptr &#125;
    &#125;
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">data</span>().ref_count.<span class="hljs-title function_ invoke__">fetch_sub</span>(<span class="hljs-number">1</span>, Release) == <span class="hljs-number">1</span> &#123;
            <span class="hljs-title function_ invoke__">fence</span>(Acquire);
            <span class="hljs-keyword">unsafe</span> &#123;
                <span class="hljs-title function_ invoke__">drop</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(<span class="hljs-keyword">self</span>.ptr.<span class="hljs-title function_ invoke__">as_ptr</span>()));
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>
<ul>
<li><code>fetch_add</code> and <code>fetch_sub</code> are used to increment and decrement the reference count.</li>
<li><code>fetch_add</code> is <code>Relaxed</code> because we don’t need to guarantee the order of the reference count, but pay attention to the next line.</li>
<li><code>fetch_sub</code> is <code>Release</code> and then <code>fence(Acquire)</code> to make sure no one is still accessing the data when we drop it.<br>
We need to guarantee that <strong>all the previous</strong> <code>fetch_sub</code> <strong><u>happens before</u></strong> the <strong>final</strong> <code>fetch_sub</code>.<br>
In hence, we can use <code>AcqRel</code> for that, however, only the final decrement needs <code>Acquire</code>, so we use <code>Release</code> + <code>fence(Acquire)</code> for efficiency.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Self-Reference">Self-Reference</h3>
<p>Futher more, if we want to handle ‘self-reference’ struct with <code>Arc</code>, it might cause memory leak, because the <code>Arc</code> will only be dropped when the reference count is zero while self-reference struct will never be zero:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123;
    value: <span class="hljs-type">String</span>,
    self_ref: <span class="hljs-type">Option</span>&lt;Arc&lt;Mutex&lt;MyStruct&gt;&gt;&gt;,
&#125;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyStruct</span> &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;
        MyStruct &#123;
            value,
            self_ref: <span class="hljs-literal">None</span>,
        &#125;
    &#125;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_reference</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: Arc&lt;Mutex&lt;MyStruct&gt;&gt;) &#123;
        <span class="hljs-keyword">self</span>.self_ref = <span class="hljs-title function_ invoke__">Some</span>(other);
    &#125;
&#125;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyStruct</span> &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;MyStruct is dropped&quot;</span>);
    &#125;
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DetectDrop</span> &#123;&#125;

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">DetectDrop</span> &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;DetectDrop is dropped&quot;</span>);
    &#125;
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(MyStruct::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())));
    <span class="hljs-keyword">let</span> <span class="hljs-variable">_b</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(DetectDrop &#123;&#125;);

    &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a_ref</span> = a.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        a_ref.<span class="hljs-title function_ invoke__">set_reference</span>(a.<span class="hljs-title function_ invoke__">clone</span>());
    &#125;

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Arc count: &#123;&#125;&quot;</span>, Arc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));
&#125;

<span class="hljs-comment">// OUTPUT:</span>
<span class="hljs-comment">// Arc count: 2</span>
<span class="hljs-comment">// DetectDrop is dropped</span></code></pre></div>
<p>So, here comes the <code>Weak</code>.</p>
<hr>
<h3 id="Weak">Weak</h3>
<p><code>Weak</code> is a non-owning reference to the managed allocation, which means it won’t increase the reference count.</p>
<p>To achieve that, we can simply split the <code>Arc</code> into <code>Weak</code> and <code>Arc</code>:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;
    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,
&#125;

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Weak</span>&lt;T&gt; &#123;
    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,
&#125;

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Weak</span>&lt;T&gt; &#123;&#125;
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Weak</span>&lt;T&gt; &#123;&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcData</span>&lt;T&gt; &#123;
    <span class="hljs-comment">/// Number of `Arc`s.</span>
    data_ref_count: AtomicUsize,
    <span class="hljs-comment">/// Number of `Weak`s, plus one if there are any `Arc`s.</span>
    alloc_ref_count: AtomicUsize,
    <span class="hljs-comment">/// The data. Dropped if there are only weak pointers left.</span>
    data: UnsafeCell&lt;ManuallyDrop&lt;T&gt;&gt;,
&#125;</code></pre></div>
<p>We’re not going to copy the code from the book, let’s just summarize the key points:</p>
<ul>
<li>Using giant numbers as a limit is feasible, in the usage scenario of <code>Arc</code>, there’re no operating systems that can handle <code>usize::MAX / 2</code> threads.</li>
<li>The inner data is still accessible even if all the <code>Arc</code> instances are dropped, because the <code>Weak</code> is still holding the <code>ArcData</code>. However, nobody can access it outside of the <code>Arc</code> crate - since we only provide <code>upgrade</code> method, and it’ll return <code>None</code>.</li>
<li><code>get_mut</code> returns <code>None</code> unless the <code>Arc</code> is the only one holding the data.</li>
</ul>
<p>Have a look at this example:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests &#123;
    <span class="hljs-keyword">use</span> std::thread::&#123;<span class="hljs-keyword">self</span>&#125;;

    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_arc</span>() &#123;
        thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">arc</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);
            <span class="hljs-comment">// only one reference, so we can get_mut</span>
            <span class="hljs-built_in">assert!</span>(Arc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> arc).<span class="hljs-title function_ invoke__">is_some</span>());

            <span class="hljs-keyword">let</span> <span class="hljs-variable">weak1</span> = Arc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;arc);
            <span class="hljs-comment">// more than one reference, so we cannot get_mut</span>
            <span class="hljs-built_in">assert!</span>(Arc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> arc).<span class="hljs-title function_ invoke__">is_none</span>());

            <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = s.<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
                thread::<span class="hljs-title function_ invoke__">park</span>();

                <span class="hljs-comment">// we cannot upgrade again</span>
                <span class="hljs-built_in">assert!</span>(weak1.<span class="hljs-title function_ invoke__">upgrade</span>().<span class="hljs-title function_ invoke__">is_none</span>());

                <span class="hljs-comment">// but the data is still there, it&#x27;s just not accessible outside of the crate</span>
                <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = weak1.<span class="hljs-title function_ invoke__">data</span>();
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;arc refs: &#123;:?&#125;&quot;</span>, d.data_ref_count.<span class="hljs-title function_ invoke__">load</span>(Relaxed));
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;weak refs: &#123;:?&#125;&quot;</span>, d.alloc_ref_count.<span class="hljs-title function_ invoke__">load</span>(Relaxed));
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;data: &#123;:?&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; &amp;*d.data.<span class="hljs-title function_ invoke__">get</span>() &#125;);
            &#125;);

            <span class="hljs-comment">// wait until the Arc is dropped</span>
            s.<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
                <span class="hljs-title function_ invoke__">drop</span>(arc);
            &#125;)
            .<span class="hljs-title function_ invoke__">join</span>()
            .<span class="hljs-title function_ invoke__">unwrap</span>();

            t.<span class="hljs-title function_ invoke__">thread</span>().<span class="hljs-title function_ invoke__">unpark</span>();
        &#125;)
    &#125;
&#125;</code></pre></div>
<h2 id="Extra-Primitives">Extra - Primitives</h2>
<p>We’ve talked about <code>UnsafeCell</code> in the first chapter <a href="#Cell-RefCell">Cell, RefCell</a>, and we’ve seen more primitives in <a href="#Chan">Chan</a> and <a href="#Arc">Arc</a>. So it’s time to summarize them:</p>
<h3 id="UnsafeCell">UnsafeCell</h3>
<p>As we’ve mentioned before, <code>UnsafeCell</code> is the core primitive for interior mutability, and it’s <u>the <span class="label label-warning">only</span> safe way to have mutable data behind a shared reference</u>.</p>
<p>E.g:</p>
<div style="display: flex; flex-direction: row; justify-content: space-between;">
  <div style="width: 49%;">
    <div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">cannot_compile</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = UnsafeCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> UnsafeCell&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>;
    <span class="hljs-keyword">unsafe</span> &#123;
        *y = <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; *x.<span class="hljs-title function_ invoke__">get</span>() &#125;);
&#125;</code></pre></div>
  </div>
  <div style="width: 49%;">
    <div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">ok</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = UnsafeCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">unsafe</span> &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x.<span class="hljs-title function_ invoke__">get</span>();
        *y = <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; *x.<span class="hljs-title function_ invoke__">get</span>() &#125;);
&#125;</code></pre></div>
  </div>
</div>
<p>Note that the complex casting in the left code is copied from <code>UnsafeCell::get()</code>, so the two snippets are <u>actually the same</u>.</p>
<p>However, the code on the left side will <u>not compile</u>, rustc will throw an error like this:</p>
<div class="note note-danger">
            <p>error: assigning to <code>&amp;T</code> is undefined behavior, consider using an <code>UnsafeCell</code></p>
          </div>
<p>Nonetheless, you can wrap the conversion in to a method of a struct to ‘make it work’:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyUnsafeCell</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; &#123;
    value: T,
&#125;

<span class="hljs-keyword">impl</span>&lt;T&gt; MyUnsafeCell&lt;T&gt; &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(v: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;
        MyUnsafeCell &#123; value: v &#125;
    &#125;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> *<span class="hljs-keyword">mut</span> T &#123;
        <span class="hljs-keyword">self</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> MyUnsafeCell&lt;T&gt; <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> T <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T
    &#125;
&#125;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ok</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = MyUnsafeCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x.<span class="hljs-title function_ invoke__">get</span>();
    <span class="hljs-keyword">unsafe</span> &#123;
        *y = <span class="hljs-number">2</span>;
    &#125;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x.value);
&#125;</code></pre></div>
<p>But this is not the right way, because:</p>
<div class="note note-light">
            <p><strong><em>Aside: lang item</em></strong></p><p>There’re some ‘black magic’ in rust – if you’re trying to copy the code of some builtin types, such as <code>UnsafeCell</code> or <code>ManuallyDrop</code>, and expect it to work just like the std lib, you might get disappointed. (Like you cannot compile the code above)</p><p>It’s even worse when you’re doing the same way with <code>ManuallyDrop</code>, because the compiler will not prevent you from writing those codes, so the unexpected behavior will happen at runtime and it’s hard to detect.</p><p>So why does the std lib work and yours does not? The answer is <code>lang item</code>.</p><p>You can find the <code>Attribute</code> above the <code>UnsafeCell</code>: <code>#[lang = &quot;unsafe_cell&quot;]</code><br>And this will make the compiler treat <code>UnsafeCell</code> as a special type, and it will be handled differently from the normal types, what’s more, this ‘handle’ is pluggable.</p><p>Check this for more detail: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nightly/unstable-book/language-features/lang-items.html"><u>lang item</u></a></p>
          </div>
<p>So, what if we put this attribute on our struct?</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[lang = <span class="hljs-string">&quot;unsafe_cell&quot;</span>]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyUnsafeCell</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; &#123;
    value: T,
&#125;</code></pre></div>
<p>Bad news, it won’t work, because this attribute cannot be redefined:</p>
<div class="note note-danger">
            <p>error[E0152]: found duplicate lang item <code>unsafe_cell</code></p>
          </div>
<p>If you insist to do so, you’ll have to build a free-standing crate yourself.<br>
Check this out: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/error_codes/E0152.html">Error code E0152, #![no_std]</a></p>
<hr>
<h3 id="NonNull">NonNull</h3>
<p>To be short, as the doc says: “<code>*mut T</code> but non-zero and <strong><em>covariant</em></strong>”.</p>
<p>So we can use it if we’re sure that the pointer is not null, and we can use it to <u>bypass the safety check of <code>*mut T</code></u> to get better performance.</p>
<h4 id="non-zero-mut-T">non-zero *mut T</h4>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-comment">// addr = 0x0</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">nptr</span>: *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span> = ptr::<span class="hljs-title function_ invoke__">null_mut</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, nptr.<span class="hljs-title function_ invoke__">is_null</span>(), nptr.<span class="hljs-title function_ invoke__">is_aligned</span>()); <span class="hljs-comment">// true true</span>

    <span class="hljs-comment">// safe</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">nnull</span> = NonNull::<span class="hljs-title function_ invoke__">new</span>(nptr);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, nnull); <span class="hljs-comment">// None</span>

    <span class="hljs-comment">// compile error in debug mode</span>
    <span class="hljs-comment">// runtime error in release mode if you try to dereference it</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">force_create</span> = <span class="hljs-keyword">unsafe</span> &#123; NonNull::<span class="hljs-title function_ invoke__">new_unchecked</span>(nptr) &#125;;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">fptr</span> = force_create.<span class="hljs-title function_ invoke__">as_ptr</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, fptr); <span class="hljs-comment">// 0x0</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; *fptr &#125;); <span class="hljs-comment">// runtime error</span>
&#125;</code></pre></div>
<p><code>NonNull</code> will prevent you from creating a null <code>NonNull</code> instance, but if you insist to do so by calling <code>new_unchecked</code>, you’ll get a runtime error(if there’re no errors, it’s still a UB) when you try to dereference it.</p>
<div class="note note-light">
            <p><strong><em>Aside: assert_unsafe_precondition!</em></strong></p><p><code>NonNull::new_unchecked</code> uses this macro to check the null pointer.</p><p>As we know, <code>xxx_unchecked</code> is a common pattern in rust, and it’s always used to bypass the safety check to improve performance.</p><p>So why does <code>NonNull</code> still check the null pointer? The secret is:</p><p>“The check is enabled at runtime if debug assertions are enabled when the caller is monomorphized. In const-eval/Miri checks implemented with this macro for language UB are always ignored.”</p><p>So, this check is only enabled in debug mode.</p><p>BTW, do you know how to enable/disable the debug assertions? There’re 3 ways:</p><ul><li>put <code>RUSTFLAGS=&quot;-C debug-assertions=on&quot;</code> before <code>cargo build</code></li><li>add <code>debug-assertions = true</code> in the <code>Cargo.toml</code></li><li>by default, <code>cargo build --release</code> will disable the debug assertions</li></ul>
          </div>
<hr>
<h4 id="covariant">covariant</h4>
<div class="note note-danger">
            <p>This is a quite complex and subtle concept, I recommend you to read this article in <em>Rustonomicon</em>: <u><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/subtyping.html">🔗Subtyping and Variance</a></u>.</p>
          </div>
<p>Anyway, let’s have a quick look of <code>Variance</code> in rust:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">debug</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(a: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, b: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) &#123;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;a:?&#125; b = &#123;b:?&#125;&quot;</span>);
&#125;</code></pre></div>
<p>We can see that <code>a</code> and <code>b</code> have the same lifetime <code>'a</code>, but does the <code>debug</code> function really requires the same lifetime for <code>a</code> and <code>b</code>?</p>
<p>The answer is <strong><em>NO</em></strong>:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;
    &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;world&quot;</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = &amp;world; <span class="hljs-comment">// &#x27;world has a shorter lifetime than &#x27;static</span>
        <span class="hljs-title function_ invoke__">debug</span>(hello, world);
    &#125;
&#125;</code></pre></div>
<p><strong>Let’s break it down without complicated concepts:</strong></p>
<ul>
<li>assume there’re 2 lifetimes: <code>'long</code> and <code>'short</code></li>
<li><code>'long</code>’s code scope completely covers <code>'short</code>’s code scope</li>
</ul>
<p>Then we can say that <code>'long</code> can be downgraded to <code>'short</code>.</p>
<div class="note note-info">
            <p>In hence, <code>debug(hello, world)</code> is:</p><p><code>debug&lt;'world&gt;('world hello, 'world world)</code></p><p>instead of</p><p><code>debug&lt;'static&gt;('static hello, 'static world)</code>.</p>
          </div>
<p><strong>Now let’s find the concepts back:</strong></p>
<ul>
<li><code>'static</code> is a <u><strong><em>SubType</em></strong></u> of <code>'world</code></li>
<li><code>'world</code> is a <u><strong><em>SuperType</em></strong></u> of <code>'static</code></li>
</ul>
<p>It’s not hard to understand the naming - we can always cast a child class into a parent class in OO languages like Java.</p>
<p>So we can always cast a <u><strong><em>SubType</em></strong></u> into a <u><strong><em>SuperType</em></strong></u> in Rust.</p>
<p><strong>Look back to <code>Variance</code>:</strong></p>
<p>‘Variance’ is another concept for describing the relationship between lifetimes. And it has 3 sub-concepts:</p>
<ul>
<li><strong>Covariant</strong>: if <code>'a</code> is a subtype of <code>'b</code>, then <code>Foo&lt;'a&gt;</code> is a subtype of <code>Foo&lt;'b&gt;</code>.</li>
<li><strong>Contravariant</strong>: if <code>'a</code> is a subtype of <code>'b</code>, then <code>Foo&lt;'b&gt;</code> is a subtype of <code>Foo&lt;'a&gt;</code>.</li>
<li><strong>Invariant</strong>: if <code>'a</code> is a subtype of <code>'b</code>, then <code>Foo&lt;'a&gt;</code> and <code>Foo&lt;'b&gt;</code> are not related to the precondition.</li>
</ul>
<p>Let’s stop here, we can find more details in the book <em>Rustonomicon</em>.</p>
<hr>
<h3 id="ManuallyDrop">ManuallyDrop</h3>
<p>A wrapper to inhibit the compiler from automatically calling <code>T</code>’s destructor and it’s 0-cost.</p>
<p>Take a look at the definition:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[stable(feature = <span class="hljs-string">&quot;manually_drop&quot;</span>, since = <span class="hljs-string">&quot;1.20.0&quot;</span>)]</span>
<span class="hljs-meta">#[lang = <span class="hljs-string">&quot;manually_drop&quot;</span>]</span>
<span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]</span>
<span class="hljs-meta">#[repr(transparent)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ManuallyDrop</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; &#123;
    value: T,
&#125;</code></pre></div>
<p>This is a <code>lang item</code> and it’s <code>repr(transparent)</code>, so it’s just a wrapper of <code>T</code>, and the implementation is a plugin of the compiler.</p>
<p>Using <code>ManuallyDrop</code> is quite simple:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DetectDrop</span>&lt;T: <span class="hljs-built_in">Debug</span>&gt; &#123;
    value: T,
&#125;

<span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Debug</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">DetectDrop</span>&lt;T&gt; &#123;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping DetectDrop with value: &#123;:?&#125;&quot;</span>, <span class="hljs-keyword">self</span>.value);
    &#125;
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-comment">// immutable, use into_inner to take the value out and drop it</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ManuallyDrop::<span class="hljs-title function_ invoke__">new</span>(DetectDrop &#123; value: <span class="hljs-number">52</span> &#125;);
    &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = ManuallyDrop::<span class="hljs-title function_ invoke__">into_inner</span>(x);
    &#125;

    <span class="hljs-comment">// mutable, use `drop` to drop the value</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = ManuallyDrop::<span class="hljs-title function_ invoke__">new</span>(DetectDrop &#123; value: <span class="hljs-number">99</span> &#125;);
    <span class="hljs-keyword">unsafe</span> &#123;
        ManuallyDrop::<span class="hljs-title function_ invoke__">drop</span>(&amp;<span class="hljs-keyword">mut</span> y);
    &#125;
&#125;</code></pre></div>
<hr>
<h3 id="MaybeUninit">MaybeUninit</h3>
<p>A wrapper to represent an value which is probably uninitialized.</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[stable(feature = <span class="hljs-string">&quot;maybe_uninit&quot;</span>, since = <span class="hljs-string">&quot;1.36.0&quot;</span>)]</span>
<span class="hljs-meta">#[lang = <span class="hljs-string">&quot;maybe_uninit&quot;</span>]</span>
<span class="hljs-meta">#[derive(Copy)]</span>
<span class="hljs-meta">#[repr(transparent)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">MaybeUninit</span>&lt;T&gt; &#123;
    uninit: (),
    value: ManuallyDrop&lt;T&gt;,
&#125;</code></pre></div>
<p>As we can see, it’s also a <code>lang item</code> and <code>repr(transparent)</code>, meanwhile it’s a wrapper of <code>ManuallyDrop&lt;T&gt;</code>.</p>
<p>The design pattern is easy to understand:</p>
<ul>
<li>when you create an <code>uninit</code> value, it’s just a <code>()</code> and it’s safe to drop</li>
<li>but when you assign a value to it, it’ll become a <code>ManuallyDrop&lt;T&gt;</code> so it’s unsafe to drop</li>
</ul>
<p>So what’s the purpose of <code>MaybeUninit</code>? Especially when we have <code>ManuallyDrop</code>?</p>
<p>A typical use is lazy initializing:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">arr</span>: [MaybeUninit&lt;<span class="hljs-type">i32</span>&gt;; <span class="hljs-number">10000</span>] = <span class="hljs-keyword">unsafe</span> &#123; MaybeUninit::<span class="hljs-title function_ invoke__">uninit</span>().<span class="hljs-title function_ invoke__">assume_init</span>() &#125;;

    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;
        arr[i] = MaybeUninit::<span class="hljs-title function_ invoke__">new</span>(i <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>);
    &#125;

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;
        sum += <span class="hljs-keyword">unsafe</span> &#123; arr[i].<span class="hljs-title function_ invoke__">assume_init</span>() &#125;;
    &#125;

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sum);
&#125;</code></pre></div>
<div class="note note-info">
            <p>The cost of the array itself cannot be reduced, but the cost of element is optimized.</p><p>The example above is quite simple, what if we replace <code>i32</code> with a complex struct? – <u>We have to call <code>T::new()</code> for each element, and those ‘zero’ values don’t take zero cost.</u></p>
          </div>
<p>You may noticed that we can replace <code>MaybeUninit</code> with <code>Option</code> in this example, so what’s the difference?</p>
<ul>
<li><code>Option</code> is a <code>enum</code> and it’s a fat pointer, while <code>MaybeUninit</code> is zero-cost.</li>
<li><code>Option</code> can tell you whether the value is initialized, but <code>MaybeUninit</code> cannot.<br>
Which indicates that you as a programmer, are responsible for keeping track of it and never reading it if it’s uninitialized</li>
</ul>
<hr>
<h3 id="PhantomData-TODO">PhantomData(TODO)</h3>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/tech/" class="category-chain-item">tech</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Rust/" class="print-no-link">#Rust</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust Atomics and Locks</div>
      <div>https://kayce.world/tech/rust_atomics_and_locks/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>kayce</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 18, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>January 20, 2025</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/tech/rust_cross_compile_on_osx/" title="Rust Cross Compile on OSX">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Rust Cross Compile on OSX</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/chores/double_entry_bookkeeping/" title="复式记账法">
                        <span class="hidden-mobile">复式记账法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"b25aa0a3d88c5fc4dbeb","clientSecret":"485e76d306112a519d43b4118efa8971c3ff6069","repo":"sshelll.github.io","owner":"sshelll","admin":["sshelll"],"language":"en-US","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'fbe76afe27bb9370648eaef592bf7f6f'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      <a>kayce</a>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
